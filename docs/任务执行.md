# 任务执行指南

## 概述

本项目支持三种类型的任务在Docker容器中执行：爬虫任务、API任务、数据库任务。所有任务都支持心跳监控、进度跟踪和优雅停止。

## 任务类型

### 1. 爬虫任务 (Crawler)
- **功能**: 网页数据采集
- **特点**: 支持多种解析器、实时进度监控
- **输出**: JSON格式的结构化数据

### 2. API任务 (API)
- **功能**: 第三方API数据采集
- **特点**: 支持认证、限流、自动重试
- **输出**: API响应数据

### 3. 数据库任务 (Database)
- **功能**: 数据库同步和迁移
- **特点**: 支持增量同步、批量处理
- **输出**: 同步结果统计

## 任务执行流程

```
1. 用户创建任务 → API接收请求
2. 任务入库 → 状态为PENDING
3. Celery调度 → 任务进入执行队列
4. Worker处理 → 启动Docker容器
5. 容器执行 → 发送心跳和进度
6. 任务完成 → 更新状态和结果
7. 资源清理 → 停止容器和清理文件
```

## 容器化执行架构

```
┌─────────────────────────────────────┐
│            Docker Container         │
├─────────────────────────────────────┤
│  ┌─────────────┐  ┌──────────────┐  │
│  │ 主进程      │  │ 任务执行线程  │  │
│  │ - 心跳发送  │  │ - 数据采集   │  │
│  │ - 状态管理  │  │ - 进度更新   │  │
│  │ - 信号处理  │  │ - 错误处理   │  │
│  └─────────────┘  └──────────────┘  │
│           │              │         │
│           └──────┬───────┘         │
│                  │                 │
│         ┌────────▼────────┐        │
│         │   共享状态对象   │        │
│         │ - 任务状态      │        │
│         │ - 执行进度      │        │
│         │ - 错误信息      │        │
│         └─────────────────┘        │
└─────────────────────────────────────┘
```

## 心跳监控机制

### 心跳发送
```python
# 容器内心跳客户端
class HeartbeatClient:
    def __init__(self, api_base_url, execution_id, container_name):
        self.api_base_url = api_base_url
        self.execution_id = execution_id
        self.container_name = container_name
        self.heartbeat_url = f"{api_base_url}/api/v1/monitoring/heartbeat"
    
    def send_heartbeat(self, status, progress=None):
        heartbeat_data = {
            "execution_id": self.execution_id,
            "container_name": self.container_name,
            "status": status,
            "progress": progress,
            "timestamp": int(time.time())
        }
        requests.post(self.heartbeat_url, json=heartbeat_data)
```

### 心跳接收
```python
# API端心跳接收
@router.post("/heartbeat")
async def heartbeat(heartbeat_data: HeartbeatRequest):
    # 更新数据库状态
    # 缓存进度信息
    # 记录心跳日志
    return {"status": "ok"}
```

## 配置文件管理

### 配置文件结构
```json
{
  "task_name": "电商网站爬虫",
  "task_type": "crawler",
  "base_url": "https://example-ecommerce.com",
  "docker_image": "data-collection-crawler:latest",
  "crawler_config": {
    "target_urls": [
      "https://example-ecommerce.com/products",
      "https://example-ecommerce.com/categories"
    ],
    "max_pages": 100,
    "delay": 2,
    "user_agent": "Mozilla/5.0 (compatible; DataCollector/1.0)",
    "output_format": "json",
    "data_fields": [
      "product_name",
      "price",
      "description",
      "category",
      "availability"
    ]
  },
  "storage_config": {
    "output_path": "/app/output",
    "filename_prefix": "ecommerce_products"
  }
}
```

### 配置文件处理流程
1. **本地处理**: 配置文件保存到 `/tmp/task_configs/{execution_id}/config.json`
2. **远程上传**: 通过SCP上传到远程执行机器
3. **Docker挂载**: 启动容器时挂载到 `/app/config.json`
4. **容器读取**: 容器内服务读取配置执行任务

## Docker容器管理

### 容器启动
```bash
docker run -d \
  --name task-{execution_id} \
  --rm \
  -v /tmp/task_configs/{execution_id}/config.json:/app/config.json:ro \
  -v /tmp/task_outputs:/app/output \
  -e TASK_EXECUTION_ID={execution_id} \
  -e CONFIG_PATH=/app/config.json \
  -e API_BASE_URL=http://your-api-host:8000 \
  {docker_image}
```

### 环境变量
| 环境变量 | 说明 | 示例值 |
|---------|------|--------|
| `TASK_EXECUTION_ID` | 任务执行ID（UUID格式） | `550e8400-e29b-41d4-a716-446655440000` |
| `CONFIG_PATH` | 配置文件在容器内的路径 | `/app/config.json` |
| `API_BASE_URL` | 主控系统API基础URL | `http://data-platform-api:8000` |
| `HOSTNAME` | 容器ID（自动设置） | `task-550e8400-e29b-41d4-a716-446655440000` |

## 容器内服务实现

### 基础心跳客户端
```python
import requests
import time
import threading
import signal
import sys

class HeartbeatClient:
    """心跳客户端 - 用于容器内服务向主控系统发送心跳"""
    
    def __init__(self, api_base_url, execution_id, container_name, heartbeat_interval=30):
        self.api_base_url = api_base_url.rstrip('/')
        self.execution_id = execution_id
        self.container_name = container_name
        self.heartbeat_interval = heartbeat_interval
        self.heartbeat_url = f"{self.api_base_url}/api/v1/monitoring/heartbeat"
        self.completion_url = f"{self.api_base_url}/api/v1/monitoring/completion"
        
        self.is_running = False
        self.heartbeat_thread = None
        self.task_status = "running"
        self.task_progress = {}
        
        # 设置信号处理器，优雅关闭
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)
    
    def start(self):
        """启动心跳服务"""
        if self.is_running:
            return
        
        self.is_running = True
        self.heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self.heartbeat_thread.start()
        print(f"心跳客户端已启动，执行ID: {self.execution_id}")
    
    def stop(self):
        """停止心跳服务"""
        self.is_running = False
        if self.heartbeat_thread:
            self.heartbeat_thread.join(timeout=5)
        print("心跳客户端已停止")
    
    def update_status(self, status, progress=None):
        """更新任务状态"""
        self.task_status = status
        if progress:
            self.task_progress.update(progress)
    
    def send_completion(self, success, result_data=None, error_message=None):
        """发送任务完成通知"""
        completion_data = {
            "execution_id": self.execution_id,
            "container_name": self.container_name,
            "success": success,
            "result_data": result_data or {},
            "error_message": error_message
        }
        
        response = requests.post(
            self.completion_url,
            json=completion_data,
            timeout=10,
            headers={'Content-Type': 'application/json'}
        )
        
        if response.status_code == 200:
            print("任务完成通知发送成功")
        else:
            print(f"任务完成通知发送失败: {response.status_code}")
```

### 任务服务示例
```python
#!/usr/bin/env python3
"""
示例：数据采集任务服务
展示如何在容器内任务中使用心跳客户端
"""

import os
import json
import time
from heartbeat_client import HeartbeatClient

def main():
    """主函数"""
    # 从环境变量获取配置
    execution_id = os.getenv('TASK_EXECUTION_ID')
    container_name = os.getenv('HOSTNAME', 'unknown-container')
    api_base_url = os.getenv('API_BASE_URL', 'http://localhost:8000')
    config_path = os.getenv('CONFIG_PATH', '/app/config.json')
    
    if not execution_id:
        print("错误: 未设置 TASK_EXECUTION_ID 环境变量")
        return 1
    
    print(f"启动任务服务 - 执行ID: {execution_id}, 容器名: {container_name}")
    
    # 初始化心跳客户端
    heartbeat_client = HeartbeatClient(
        api_base_url=api_base_url,
        execution_id=execution_id,
        container_name=container_name,
        heartbeat_interval=30
    )
    
    try:
        # 启动心跳
        heartbeat_client.start()
        
        # 读取任务配置
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        print(f"任务配置: {config['task_name']}")
        heartbeat_client.update_status("running", {"stage": "配置加载完成"})
        
        # 模拟任务执行
        total_steps = 10
        for step in range(1, total_steps + 1):
            # 更新进度
            progress = {
                "stage": "数据处理中",
                "current_step": step,
                "total_steps": total_steps,
                "percentage": round(step / total_steps * 100, 2)
            }
            heartbeat_client.update_status("running", progress)
            
            print(f"执行步骤 {step}/{total_steps}")
            
            # 模拟处理时间
            time.sleep(5)
        
        # 任务完成
        heartbeat_client.update_status("completed", {"stage": "任务完成"})
        
        # 发送完成通知
        result_data = {
            "processed_records": 1000,
            "output_files": ["result.json", "summary.txt"],
            "execution_time": "2.5分钟"
        }
        
        heartbeat_client.send_completion(
            success=True,
            result_data=result_data
        )
        
        print("任务执行完成")
        return 0
        
    except Exception as e:
        print(f"任务执行异常: {e}")
        heartbeat_client.send_completion(
            success=False,
            error_message=str(e)
        )
        return 1
        
    finally:
        # 停止心跳
        heartbeat_client.stop()

if __name__ == "__main__":
    exit(main())
```

## Docker镜像构建

### Dockerfile示例
```dockerfile
FROM python:3.9-slim

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    libxml2-dev \
    libxslt1-dev \
    zlib1g-dev \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖
COPY requirements.txt /app/
WORKDIR /app
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY heartbeat_client.py /app/
COPY task_service.py /app/

# 设置环境变量
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# 创建输出目录
RUN mkdir -p /app/output

# 运行任务服务
CMD ["python", "task_service.py"]
```

### requirements.txt
```txt
requests>=2.25.1
beautifulsoup4>=4.9.3
lxml>=4.6.3
selenium>=4.0.0
fake-useragent>=1.1.0
```

## 网络配置

### 容器网络访问
确保Docker容器能够访问主控系统的API：

1. **同一Docker网络**: 将任务容器加入与API服务相同的Docker网络
2. **端口映射**: 如果API服务有端口映射，使用宿主机IP访问
3. **服务发现**: 使用Docker Compose的服务名进行访问

### 远端Docker配置
当使用远端Docker守护进程时：

```bash
# 环境变量配置
DOCKER_HOST=tcp://172.28.214.138:2375
DOCKER_HOST_IP=127.0.0.1
API_BASE_URL=http://localhost:8000
```

## 监控和调试

### 任务状态监控
```bash
# 查看任务状态
curl http://localhost:8000/api/v1/task/execution/{execution_id}/status

# 查看心跳信息
curl http://localhost:8000/api/v1/monitoring/heartbeat/{execution_id}
```

### 容器日志查看
```bash
# 查看容器日志
docker logs task-{execution_id}

# 实时查看日志
docker logs -f task-{execution_id}
```

### 调试技巧
1. **启用详细日志**
   ```python
   import logging
   logging.basicConfig(level=logging.DEBUG)
   ```

2. **测试网络连接**
   ```bash
   # 在容器内测试API连接
   curl -X POST http://api-host:8000/api/v1/monitoring/heartbeat \
     -H "Content-Type: application/json" \
     -d '{"execution_id":"test","container_name":"test","status":"running"}'
   ```

3. **检查环境变量**
   ```bash
   # 在容器内查看环境变量
   env | grep -E "(TASK_EXECUTION_ID|CONFIG_PATH|API_BASE_URL)"
   ```

## 故障排除

### 常见问题

1. **容器启动失败**
   - 检查Docker镜像是否存在
   - 确认远程机器Docker服务运行正常
   - 检查挂载路径是否正确

2. **心跳发送失败**
   - 检查网络连接
   - 确认API服务地址正确
   - 检查防火墙设置

3. **任务执行超时**
   - 检查任务配置是否合理
   - 增加超时时间设置
   - 查看容器日志排查具体问题

4. **配置文件读取失败**
   - 检查配置文件挂载路径
   - 确认文件权限
   - 验证JSON格式正确性

## 最佳实践

### 1. 容器设计
- 使用轻量级基础镜像
- 合理设置资源限制
- 实现优雅停止机制

### 2. 心跳机制
- 设置合理的心跳间隔
- 实现心跳失败重试
- 记录详细的心跳日志

### 3. 错误处理
- 实现完善的异常捕获
- 提供详细的错误信息
- 支持任务重试机制

### 4. 资源管理
- 及时清理临时文件
- 合理使用内存和CPU
- 监控资源使用情况

## 总结

通过容器化任务执行方案，我们实现了：

1. **🎯 隔离执行**: 任务在独立容器中运行，互不影响
2. **💓 实时监控**: 心跳机制确保任务状态实时更新
3. **🔄 优雅停止**: 支持信号处理和优雅关闭
4. **📊 进度跟踪**: 实时监控任务执行进度
5. **🛠️ 灵活配置**: 通过配置文件灵活控制任务行为
6. **🔧 易于调试**: 完善的日志和监控机制

这个方案确保了任务执行的稳定性、可监控性和可维护性。
