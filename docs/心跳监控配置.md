# 心跳监控配置说明

## 概述

心跳监控系统用于检测Docker任务的健康状态，通过定时检查任务的心跳状态来识别超时和失联的任务。

## 配置参数

### 环境变量配置

在 `.env` 文件中配置以下参数：

```ini
# 心跳超时时间（秒）
HEARTBEAT_TIMEOUT=300

# 时区设置
TIMEZONE=Asia/Shanghai
```

### 默认配置

- **心跳超时时间**: 300秒（5分钟）
- **监控检查间隔**: 120秒（2分钟）
- **最大超时次数**: 3次
- **时区**: Asia/Shanghai

## 监控逻辑

### 1. 心跳检测

- 每2分钟执行一次心跳监控任务
- 检查所有状态为 `RUNNING` 的任务
- 比较 `last_heartbeat` 时间与当前时间

### 2. 超时判断

#### 首次心跳检测
- 如果任务启动后从未发送心跳，且超过启动时间 + 心跳超时时间，标记为失联

#### 后续心跳检测
- 如果 `last_heartbeat` 时间超过心跳超时时间，记录超时次数
- 使用Redis存储每个任务的超时计数：`heartbeat_timeout_count:{execution_id}`

### 3. 失联标记

- 连续超时3次后，将任务状态标记为 `FAILED`
- 记录失联原因：`任务连续心跳超时 {count} 次，已失联`
- 清除Redis中的超时计数

### 4. 心跳恢复

- 如果任务恢复正常心跳，自动清除超时计数
- 任务可以继续正常运行

## 调度配置

### Celery Beat 调度

```python
beat_schedule = {
    # 心跳监控任务 - 每2分钟执行一次
    'heartbeat-monitor': {
        'task': 'heartbeat_monitor_task',
        'schedule': 120.0,  # 2分钟
        'options': {'queue': 'monitoring'}
    },
    # 系统健康检查 - 每5分钟执行一次
    'system-health-check': {
        'task': 'system_health_check_task',
        'schedule': 300.0,  # 5分钟
        'options': {'queue': 'health_check'}
    },
    # 每日清理任务 - 每天执行一次
    'daily-cleanup': {
        'task': 'daily_cleanup_task',
        'schedule': 86400.0,  # 24小时
        'options': {'queue': 'cleanup'}
    },
}
```

## 任务队列

心跳监控任务运行在 `monitoring` 队列中：

```bash
# 启动监控队列的worker
pdm run celery:worker --queues=monitoring

# 启动beat调度器
pdm run celery:beat
```

## 监控指标

### Redis存储

- **超时计数**: `heartbeat_timeout_count:{execution_id}` 
- **过期时间**: 心跳超时时间的2倍（防止内存泄漏）

### 数据库字段

- **last_heartbeat**: 最后心跳时间
- **status**: 任务状态（RUNNING/FAILED）
- **error_log**: 失联原因

## 测试

使用测试脚本验证心跳监控功能：

```bash
# 运行心跳监控测试
python test_heartbeat_monitor.py
```

测试包括：
1. 正常心跳发送
2. 心跳超时检测
3. 失联标记
4. 任务完成通知

## 故障处理

### 常见问题

1. **Redis连接失败**
   - 检查Redis服务状态
   - 验证Redis连接配置

2. **监控任务不执行**
   - 检查Celery Beat是否启动
   - 验证任务队列配置

3. **误报失联**
   - 调整心跳超时时间
   - 检查网络连接

### 日志监控

监控以下日志信息：
- `任务心跳超时第 {count} 次`
- `任务连续超时 {count} 次，标记为失联`
- `心跳监控完成，处理了 {processed} 个任务`

## 性能优化

### 批量处理
- 一次监控检查处理所有运行中的任务
- 减少数据库查询次数

### 缓存策略
- 使用Redis缓存超时计数
- 自动过期清理避免内存泄漏

### 并发控制
- 监控任务运行在独立队列
- 避免与其他任务竞争资源
