# 数据库驱动说明

## 当前配置

### 异步驱动：asyncmy

本项目使用 **asyncmy** 作为 MySQL 异步驱动。

**连接字符串：**
```
mysql+asyncmy://user:password@host:port/database
```

**依赖：**
- `asyncmy>=0.2.10`
- `greenlet`

---

## 特点说明

### ✅ 优势

1. **性能优秀**
   - 比 aiomysql 性能更好
   - 专为高并发设计

2. **现代化**
   - 维护活跃
   - 与 SQLAlchemy 2.0 完美兼容

3. **功能完整**
   - 支持所有 MySQL 特性
   - 与 FastAPI 集成良好

### ⚠️ 注意事项

#### 启动预热期

**现象：**
- 服务启动后 **前 15-20 秒**，部分请求可能失败
- 错误：`Task got Future attached to a different loop`

**原因：**
- 数据库连接池初始化需要时间
- 异步事件循环预热

**解决方案：**
1. **生产环境**：
   - 配置健康检查延迟启动（readiness probe delay）
   - Kubernetes: `initialDelaySeconds: 20`
   - Docker Compose: `healthcheck.start_period: 20s`

2. **开发环境**：
   - 等待服务完全启动（看到 "Application startup complete"）
   - 等待 15-20 秒后再调用 API

3. **API 调用端**：
   - 添加重试机制（推荐 3 次，间隔 2 秒）

---

## 使用建议

### 健康检查配置

#### Docker Compose
```yaml
services:
  api:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8089/api/v1/common/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s  # ⭐ 重要：启动预热期
```

#### Kubernetes
```yaml
livenessProbe:
  httpGet:
    path: /api/v1/common/health/liveness
    port: 8089
  initialDelaySeconds: 20  # ⭐ 重要：启动延迟
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /api/v1/common/health/readiness
    port: 8089
  initialDelaySeconds: 20  # ⭐ 重要：启动延迟
  periodSeconds: 5
```

### 客户端重试示例

```python
import httpx
import time

async def call_api_with_retry(url, max_retries=3):
    """API 调用带重试"""
    for i in range(max_retries):
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(url, ...)
                return response.json()
        except Exception as e:
            if i < max_retries - 1:
                await asyncio.sleep(2)  # 等待 2 秒后重试
                continue
            raise
```

---

## 性能优化

### 连接池配置

当前配置（已优化）：
```python
DATABASE_POOL_SIZE = 20        # 连接池大小
DATABASE_MAX_OVERFLOW = 30     # 最大溢出连接
DATABASE_POOL_TIMEOUT = 60     # 获取连接超时
DATABASE_POOL_RECYCLE = 1800   # 连接回收时间（30分钟）
```

**说明：**
- 已移除 `pool_pre_ping`（避免事件循环冲突）
- 适合中等并发量（100-200 QPS）

---

## 替代方案

如果遇到无法接受的问题，可以考虑：

### 方案 1: mysql-connector-python（官方）
```bash
pdm remove asyncmy
pdm add mysql-connector-python

# 修改连接字符串
DATABASE_URL = "mysql+mysqlconnector://..."
```

**优点：** 官方维护，稳定性最好  
**缺点：** 性能略逊于 asyncmy

### 方案 2: Tortoise ORM（完全不同）
```bash
pdm add tortoise-orm
```

**优点：** 原生异步，无事件循环问题  
**缺点：** 需要重写所有代码

---

## 监控建议

### 1. 启动健康检查

使用提供的脚本等待服务就绪：
```bash
# 自动等待服务完全就绪（包含数据库连接池初始化）
bash scripts/wait_for_ready.sh

# 或手动等待
while ! curl -f http://localhost:8089/api/v1/common/health; do
    echo "等待服务启动..."
    sleep 2
done
sleep 15  # 额外等待数据库连接池初始化
echo "✅ 服务已就绪"
```

### 2. 连接池监控
在生产环境监控以下指标：
- 连接池使用率
- 连接获取超时次数
- 数据库查询耗时

---

## 快速开始

### 开发环境
```bash
# 1. 启动服务
pdm run start

# 2. 等待 20 秒
sleep 20

# 3. 开始使用 API
curl http://localhost:8089/api/v1/docs
```

### 生产环境
```bash
# 使用 Docker Compose（已配置健康检查）
docker-compose up -d

# 或使用 Kubernetes（已配置 readiness probe）
kubectl apply -f deployment.yaml
```

---

## 总结

✅ **asyncmy 是当前最佳选择**
- 性能好
- 与 SQLAlchemy 兼容
- 维护活跃

⚠️ **需要注意启动预热期**
- 配置健康检查延迟
- 客户端添加重试
- 等待 15-20 秒后服务完全稳定

📝 **监控要点**
- 关注连接池使用情况
- 监控启动时间
- 记录异常请求

---

**更新时间：** 2025-10-15  
**驱动版本：** asyncmy 0.2.10

