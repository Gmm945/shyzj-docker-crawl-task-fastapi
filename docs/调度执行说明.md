# 调度执行说明

## 📋 概述

本系统支持灵活的任务调度功能，可以按照不同的时间策略自动执行爬虫任务。调度系统基于 Celery Beat 实现，支持立即执行、定时执行、周期执行等多种模式。

## 🎯 调度类型

系统支持以下 4 种调度类型：

| 调度类型 | 枚举值 | 说明 | 适用场景 |
|---------|--------|------|---------|
| **立即执行** | `immediate` | 创建后立即执行 | 临时测试、手动触发 |
| **定时执行** | `scheduled` | 指定时间执行一次 | 特定时间点的任务 |
| **周调度** | `weekly` | 每周固定时间执行 | 周报、周期性数据采集 |
| **月调度** | `monthly` | 每月固定日期执行 | 月报、账单数据采集 |

---

## 🔧 调度配置说明

### 1. 立即执行 (immediate)

**配置格式**：
```json
{
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "schedule_type": "immediate",
  "schedule_config": {}
}
```

**说明**：
- 无需配置参数
- 创建后立即执行
- 适合临时测试和手动触发

---

### 2. 定时执行 (scheduled)

**配置格式**：
```json
{
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "schedule_type": "scheduled",
  "schedule_config": {
    "datetime": "2025-10-15 14:30:00"
  }
}
```

**参数说明**：
- `datetime`: 指定的执行时间（格式：`YYYY-MM-DD HH:MM:SS`）

**特点**：
- 一次性执行
- 执行后自动禁用
- 适合特定时间点的任务

**示例**：
```bash
# 在 2025年10月15日 下午2点30分 执行一次
{
  "datetime": "2025-10-15 14:30:00"
}
```

---

### 3. 周调度 (weekly)

**配置格式**：
```json
{
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "schedule_type": "weekly",
  "schedule_config": {
    "days": [1, 3, 5],
    "time": "09:00:00"
  }
}
```

**参数说明**：
- `days`: 一周中的哪几天执行（1=周一，2=周二，...，7=周日）
- `time`: 每天的执行时间（格式：`HH:MM:SS`）

**特点**：
- 周期性重复执行
- 支持多天配置
- 自动计算下次执行时间

**示例**：
```bash
# 每周一、三、五早上9点执行
{
  "days": [1, 3, 5],
  "time": "09:00:00"
}

# 每周末（周六、周日）下午5点执行
{
  "days": [6, 7],
  "time": "17:00:00"
}
```

---

### 4. 月调度 (monthly)

**配置格式**：
```json
{
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "schedule_type": "monthly",
  "schedule_config": {
    "dates": [1, 15],
    "time": "10:00:00"
  }
}
```

**参数说明**：
- `dates`: 每月的哪几号执行（1-31）
- `time`: 每天的执行时间（格式：`HH:MM:SS`）

**特点**：
- 按月重复执行
- 支持多个日期
- 自动处理不存在的日期（如2月30日）

**示例**：
```bash
# 每月1号和15号早上10点执行
{
  "dates": [1, 15],
  "time": "10:00:00"
}

# 每月最后一天下午6点执行
{
  "dates": [31],
  "time": "18:00:00"
}
```

---

## 🚀 API 接口说明

### 1. 创建调度

**接口**: `POST /api/v1/scheduler/`

**请求头**：
```
Authorization: Bearer {access_token}
Content-Type: application/json
```

**请求体**：
```json
{
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "schedule_type": "weekly",
  "schedule_config": {
    "days": [1, 3, 5],
    "time": "09:00:00"
  }
}
```

**响应示例**：
```json
{
  "message": "调度创建成功",
  "data": {
    "schedule_id": "a472132c-130a-456a-b05f-c5ebf36d5418"
  }
}
```

**cURL 示例**：
```bash
curl -X POST "http://localhost:8089/api/v1/scheduler/" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "task_id": "550e8400-e29b-41d4-a716-446655440000",
    "schedule_type": "weekly",
    "schedule_config": {
      "days": [1, 3, 5],
      "time": "09:00:00"
    }
  }'
```

---

### 2. 查询任务的调度配置

**接口**: `GET /api/v1/scheduler/task/{task_id}`

**请求头**：
```
Authorization: Bearer {access_token}
```

**响应示例**：
```json
{
  "message": "success",
  "data": [
    {
      "id": "a472132c-130a-456a-b05f-c5ebf36d5418",
      "task_id": "550e8400-e29b-41d4-a716-446655440000",
      "schedule_type": "weekly",
      "schedule_config": {
        "days": [1, 3, 5],
        "time": "09:00:00"
      },
      "is_active": true,
      "next_run_time": "2025-10-13T09:00:00",
      "create_time": "2025-10-09T10:30:00"
    }
  ]
}
```

**cURL 示例**：
```bash
curl -X GET "http://localhost:8089/api/v1/scheduler/task/550e8400-e29b-41d4-a716-446655440000" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

---

### 3. 启用/禁用调度

**接口**: `PUT /api/v1/scheduler/{schedule_id}/toggle`

**请求头**：
```
Authorization: Bearer {access_token}
```

**响应示例**：
```json
{
  "message": "调度启用成功"
}
```

**cURL 示例**：
```bash
# 切换调度状态（启用 ↔ 禁用）
curl -X PUT "http://localhost:8089/api/v1/scheduler/a472132c-130a-456a-b05f-c5ebf36d5418/toggle" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

---

### 4. 删除调度

**接口**: `DELETE /api/v1/scheduler/{schedule_id}`

**请求头**：
```
Authorization: Bearer {access_token}
```

**响应示例**：
```json
{
  "message": "调度删除成功"
}
```

**cURL 示例**：
```bash
curl -X DELETE "http://localhost:8089/api/v1/scheduler/a472132c-130a-456a-b05f-c5ebf36d5418" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

---

## ⚙️ 调度执行机制

### 工作流程

```
┌─────────────────────────────────────────────────────────────┐
│                     调度执行流程                              │
└─────────────────────────────────────────────────────────────┘

1. 用户创建调度
   POST /api/v1/scheduler/
   ↓
   ├─ 验证任务存在
   ├─ 验证权限
   ├─ 检查是否已有活跃调度
   └─ 计算 next_run_time

2. 保存到数据库
   task_schedules 表
   ↓
   ├─ task_id
   ├─ schedule_type
   ├─ schedule_config
   ├─ next_run_time  ← 关键字段
   └─ is_active

3. Celery Beat 定时检查
   每分钟执行一次
   ↓
   SELECT * FROM task_schedules
   WHERE is_active = TRUE
   AND next_run_time <= NOW()

4. 执行到期任务
   ↓
   ├─ 检查任务是否正在运行
   ├─ 创建 TaskExecution 记录
   ├─ 提交到 Celery 队列
   └─ 更新 next_run_time

5. 启动 Docker 容器
   execute_data_collection_task
   ↓
   执行爬虫任务
```

### 核心组件

| 组件 | 说明 | 文件位置 |
|------|------|---------|
| **Celery Beat** | 定时调度器，每分钟检查一次 | `src/worker/celeryconfig.py` |
| **process_scheduled_tasks** | 处理到期的调度任务 | `src/worker/scheduler_tasks.py` |
| **ScheduleUtils** | 计算下次执行时间 | `src/utils/schedule_utils.py` |
| **TaskSchedule** | 调度配置数据模型 | `src/data_platform_api/models/task.py` |

### Celery Beat 配置

```python
# src/worker/celeryconfig.py
beat_schedule = {
    'process-scheduled-tasks': {
        'task': 'process_scheduled_tasks',
        'schedule': crontab(minute='*'),  # 每分钟执行
        'options': {'queue': 'scheduler'}
    }
}
```

### 下次执行时间计算

系统会根据调度类型自动计算下次执行时间：

**周调度示例**：
```python
# 当前时间：2025-10-09 周三 10:00
# 配置：每周一、三、五 09:00
# 计算结果：2025-10-11 周五 09:00
```

**月调度示例**：
```python
# 当前时间：2025-10-09
# 配置：每月1号和15号 10:00
# 计算结果：2025-10-15 10:00
```

---

## 🔒 权限控制

### 权限规则

1. **创建调度**：
   - 管理员可以为任何任务创建调度
   - 普通用户只能为自己创建的任务创建调度

2. **查询调度**：
   - 管理员可以查看所有调度
   - 普通用户只能查看自己任务的调度

3. **修改/删除调度**：
   - 管理员可以操作所有调度
   - 普通用户只能操作自己任务的调度

### 验证逻辑

```python
# 检查任务权限
if not current_user.is_admin and task.creator_id != current_user.id:
    raise HTTPException(status_code=403, detail="无权调度此任务")
```

---

## 📝 使用示例

### 场景 1：每日数据采集

**需求**：每天早上 8 点采集电商网站的商品数据

**解决方案**：使用周调度，设置每天执行
```json
{
  "task_id": "your-task-id",
  "schedule_type": "weekly",
  "schedule_config": {
    "days": [1, 2, 3, 4, 5, 6, 7],
    "time": "08:00:00"
  }
}
```

---

### 场景 2：工作日数据采集

**需求**：每个工作日（周一到周五）下午 6 点采集新闻数据

**解决方案**：使用周调度，只设置工作日
```json
{
  "task_id": "your-task-id",
  "schedule_type": "weekly",
  "schedule_config": {
    "days": [1, 2, 3, 4, 5],
    "time": "18:00:00"
  }
}
```

---

### 场景 3：月度报表

**需求**：每月1号凌晨 2 点生成上月数据报表

**解决方案**：使用月调度
```json
{
  "task_id": "your-task-id",
  "schedule_type": "monthly",
  "schedule_config": {
    "dates": [1],
    "time": "02:00:00"
  }
}
```

---

### 场景 4：双周报表

**需求**：每月 1 号和 15 号生成报表

**解决方案**：使用月调度，设置两个日期
```json
{
  "task_id": "your-task-id",
  "schedule_type": "monthly",
  "schedule_config": {
    "dates": [1, 15],
    "time": "00:00:00"
  }
}
```

---

### 场景 5：一次性任务

**需求**：在促销活动开始时（2025-11-11 00:00）采集数据

**解决方案**：使用定时执行
```json
{
  "task_id": "your-task-id",
  "schedule_type": "scheduled",
  "schedule_config": {
    "datetime": "2025-11-11 00:00:00"
  }
}
```

---

## 🛠️ 启动调度服务

### 方式一：使用 PDM

```bash
# 1. 启动 FastAPI 服务
pdm run start

# 2. 启动 Celery Worker（执行任务）
pdm run worker

# 3. 启动 Celery Beat（定时调度器）
pdm run beat

# 4. （可选）启动 Flower 监控界面
pdm run flower
```

### 方式二：使用 Docker Compose

```bash
# 启动所有服务
docker-compose -f docker/docker-compose.yml up -d

# 查看日志
docker-compose -f docker/docker-compose.yml logs -f
```

### 方式三：手动启动

```bash
# 1. 启动 API 服务
uvicorn src.main:app --host 0.0.0.0 --port 8089 --reload

# 2. 启动 Worker
celery -A src.worker.main worker \
  -Q task_execution,docker_management,monitoring,scheduler,cleanup,health_check \
  -l info --concurrency=4

# 3. 启动 Beat
celery -A src.worker.main beat --loglevel=info

# 4. 启动 Flower
celery -A src.worker.main flower --port=5555 --basic_auth=admin:admin123
```

### 验证服务状态

```bash
# 检查 API 服务
curl http://localhost:8089/api/v1/

# 检查 Celery Worker
celery -A src.worker.main inspect active

# 检查 Celery Beat
celery -A src.worker.main inspect scheduled

# 访问 Flower 监控
open http://localhost:5555
```

---

## 📊 监控和管理

### 查看调度状态

```sql
-- 查看所有活跃的调度
SELECT 
  ts.id,
  t.task_name,
  ts.schedule_type,
  ts.next_run_time,
  ts.is_active
FROM task_schedules ts
JOIN tasks t ON ts.task_id = t.id
WHERE ts.is_active = TRUE
ORDER BY ts.next_run_time;

-- 查看即将执行的调度（未来1小时内）
SELECT 
  ts.id,
  t.task_name,
  ts.schedule_type,
  ts.next_run_time,
  TIMESTAMPDIFF(MINUTE, NOW(), ts.next_run_time) AS minutes_until_run
FROM task_schedules ts
JOIN tasks t ON ts.task_id = t.id
WHERE ts.is_active = TRUE
  AND ts.next_run_time BETWEEN NOW() AND DATE_ADD(NOW(), INTERVAL 1 HOUR)
ORDER BY ts.next_run_time;
```

### 查看执行历史

```sql
-- 查看任务执行记录
SELECT 
  te.id,
  t.task_name,
  te.status,
  te.start_time,
  te.end_time,
  TIMESTAMPDIFF(SECOND, te.start_time, te.end_time) AS duration_seconds
FROM task_executions te
JOIN tasks t ON te.task_id = t.id
WHERE te.start_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
ORDER BY te.start_time DESC;
```

### Flower 监控界面

访问 http://localhost:5555 查看：
- 任务执行状态
- Worker 状态
- 任务队列情况
- 执行历史和统计

---

## ⚠️ 注意事项

### 1. 时区设置

系统默认使用 `Asia/Shanghai` 时区：

```python
# celery_beat_schedule.py
timezone = "Asia/Shanghai"
```

如需修改时区，请同步修改相关配置。

### 2. 避免重复执行

系统会自动检查任务是否正在运行：

```python
# 如果任务正在运行，跳过本次调度
if running_execution:
    logger.info(f"任务正在运行中，跳过此次调度")
    return True
```

### 3. 调度唯一性

每个任务同时只能有**一个活跃的调度**：

```python
# 检查是否已有活跃的调度
existing_schedule = await db.execute(
    select(TaskSchedule).where(
        TaskSchedule.task_id == task_id,
        TaskSchedule.is_active == True
    )
)
```

如需修改调度配置：
1. 禁用或删除现有调度
2. 创建新的调度配置

### 4. 执行延迟

- Celery Beat 每分钟检查一次
- 实际执行时间可能有 0-60 秒的延迟
- 对于精确时间要求高的任务，建议提前配置

### 5. 容错机制

- 如果调度执行失败，系统会记录错误日志
- `next_run_time` 仍会更新，等待下次执行
- 可通过 Flower 或日志查看失败原因

---

## 🐛 故障排查

### 问题 1：调度未按时执行

**可能原因**：
1. Celery Beat 未启动
2. 调度被禁用（`is_active = false`）
3. `next_run_time` 设置错误

**排查步骤**：
```bash
# 1. 检查 Celery Beat 是否运行
ps aux | grep "celery.*beat"

# 2. 查看调度状态
SELECT * FROM task_schedules WHERE task_id = 'your-task-id';

# 3. 查看 Celery Beat 日志
tail -f /path/to/celery-beat.log
```

---

### 问题 2：调度创建失败

**错误信息**: `任务已有活跃的调度配置`

**解决方案**：
```bash
# 1. 查询现有调度
curl -X GET "http://localhost:8089/api/v1/scheduler/task/{task_id}" \
  -H "Authorization: Bearer YOUR_TOKEN"

# 2. 删除现有调度
curl -X DELETE "http://localhost:8089/api/v1/scheduler/{schedule_id}" \
  -H "Authorization: Bearer YOUR_TOKEN"

# 3. 创建新调度
curl -X POST "http://localhost:8089/api/v1/scheduler/" ...
```

---

### 问题 3：任务未执行

**可能原因**：
1. Celery Worker 未启动
2. 任务队列阻塞
3. Docker 容器启动失败

**排查步骤**：
```bash
# 1. 检查 Worker 状态
celery -A src.worker.main inspect active

# 2. 查看任务执行记录
SELECT * FROM task_executions 
WHERE task_id = 'your-task-id' 
ORDER BY create_time DESC 
LIMIT 10;

# 3. 查看容器日志
docker logs task-{execution_id}
```

---

## 📚 相关文档

- [任务执行文档](./任务执行.md) - Docker 容器化任务执行说明
- [心跳监控配置](./心跳监控配置.md) - 任务监控和心跳机制
- [项目架构](./项目架构.md) - 系统整体架构说明
- [数据库管理](./数据库管理.md) - 数据库相关操作

---

## 🔗 API 文档

- Swagger UI: http://localhost:8089/docs
- ReDoc: http://localhost:8089/redoc

---

## 📞 技术支持

如遇到问题，请：

1. 查看系统日志
2. 检查 Flower 监控界面
3. 查看数据库调度记录
4. 提交 Issue 或联系技术支持

---

**文档版本**: 1.0.0  
**最后更新**: 2025-10-09  
**维护者**: Data Platform Team

