# 容器内服务心跳示例

## 概述

本文档展示了如何在Docker容器内的任务服务中调用 `/monitoring/heartbeat` 接口，实现任务执行状态的实时上报。

## Python示例代码

### 基础心跳客户端类

```python
import requests
import time
import json
import os
from datetime import datetime
from typing import Optional, Dict, Any
import threading
import signal
import sys

class HeartbeatClient:
    """心跳客户端 - 用于容器内服务向主控系统发送心跳"""
    
    def __init__(self, 
                 api_base_url: str,
                 execution_id: str,
                 container_id: str,
                 heartbeat_interval: int = 30):
        """
        初始化心跳客户端
        
        Args:
            api_base_url: 主控系统的API基础URL
            execution_id: 任务执行ID
            container_id: Docker容器ID
            heartbeat_interval: 心跳间隔（秒）
        """
        self.api_base_url = api_base_url.rstrip('/')
        self.execution_id = execution_id
        self.container_id = container_id
        self.heartbeat_interval = heartbeat_interval
        self.heartbeat_url = f"{self.api_base_url}/api/v1/monitoring/heartbeat"
        self.completion_url = f"{self.api_base_url}/api/v1/monitoring/completion"
        
        self.is_running = False
        self.heartbeat_thread = None
        self.task_status = "running"
        self.task_progress = {}
        
        # 设置信号处理器，优雅关闭
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """信号处理器"""
        print(f"收到信号 {signum}，正在关闭心跳客户端...")
        self.stop()
        sys.exit(0)
    
    def start(self):
        """启动心跳服务"""
        if self.is_running:
            return
        
        self.is_running = True
        self.heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self.heartbeat_thread.start()
        print(f"心跳客户端已启动，执行ID: {self.execution_id}")
    
    def stop(self):
        """停止心跳服务"""
        self.is_running = False
        if self.heartbeat_thread:
            self.heartbeat_thread.join(timeout=5)
        print("心跳客户端已停止")
    
    def update_status(self, status: str, progress: Optional[Dict[str, Any]] = None):
        """
        更新任务状态
        
        Args:
            status: 任务状态 (running, completed, failed)
            progress: 任务进度信息
        """
        self.task_status = status
        if progress:
            self.task_progress.update(progress)
    
    def _heartbeat_loop(self):
        """心跳循环"""
        while self.is_running:
            try:
                self._send_heartbeat()
                time.sleep(self.heartbeat_interval)
            except Exception as e:
                print(f"心跳发送失败: {e}")
                time.sleep(5)  # 失败后等待5秒再重试
    
    def _send_heartbeat(self):
        """发送心跳"""
        try:
            heartbeat_data = {
                "execution_id": self.execution_id,
                "container_id": self.container_id,
                "status": self.task_status,
                "progress": self.task_progress,
                "timestamp": int(time.time())
            }
            
            response = requests.post(
                self.heartbeat_url,
                json=heartbeat_data,
                timeout=10,
                headers={'Content-Type': 'application/json'}
            )
            
            if response.status_code == 200:
                result = response.json()
                if result.get('status') == 'ok':
                    print(f"心跳发送成功: {datetime.now().isoformat()}")
                else:
                    print(f"心跳响应异常: {result}")
            else:
                print(f"心跳请求失败: {response.status_code} - {response.text}")
                
        except requests.exceptions.RequestException as e:
            print(f"心跳网络请求异常: {e}")
        except Exception as e:
            print(f"心跳发送异常: {e}")
    
    def send_completion(self, success: bool, result_data: Optional[Dict[str, Any]] = None, 
                       error_message: Optional[str] = None):
        """
        发送任务完成通知
        
        Args:
            success: 任务是否成功
            result_data: 任务结果数据
            error_message: 错误信息（如果任务失败）
        """
        try:
            completion_data = {
                "execution_id": self.execution_id,
                "container_id": self.container_id,
                "success": success,
                "result_data": result_data or {},
                "error_message": error_message
            }
            
            response = requests.post(
                self.completion_url,
                json=completion_data,
                timeout=10,
                headers={'Content-Type': 'application/json'}
            )
            
            if response.status_code == 200:
                print("任务完成通知发送成功")
            else:
                print(f"任务完成通知发送失败: {response.status_code} - {response.text}")
                
        except Exception as e:
            print(f"发送任务完成通知异常: {e}")
```

### 在任务服务中使用心跳客户端

```python
#!/usr/bin/env python3
"""
示例：数据采集任务服务
展示如何在容器内任务中使用心跳客户端
"""

import os
import json
import time
from heartbeat_client import HeartbeatClient

def main():
    """主函数"""
    # 从环境变量获取配置
    execution_id = os.getenv('TASK_EXECUTION_ID')
    container_id = os.getenv('HOSTNAME', 'unknown-container')
    api_base_url = os.getenv('API_BASE_URL', 'http://localhost:8000')
    config_path = os.getenv('CONFIG_PATH', '/app/config/config.json')
    
    if not execution_id:
        print("错误: 未设置 TASK_EXECUTION_ID 环境变量")
        return 1
    
    print(f"启动任务服务 - 执行ID: {execution_id}, 容器ID: {container_id}")
    
    # 初始化心跳客户端
    heartbeat_client = HeartbeatClient(
        api_base_url=api_base_url,
        execution_id=execution_id,
        container_id=container_id,
        heartbeat_interval=30  # 30秒发送一次心跳
    )
    
    try:
        # 启动心跳
        heartbeat_client.start()
        
        # 读取任务配置
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        print(f"任务配置: {config['task_name']}")
        heartbeat_client.update_status("running", {"stage": "配置加载完成"})
        
        # 模拟任务执行
        total_steps = 10
        for step in range(1, total_steps + 1):
            # 更新进度
            progress = {
                "stage": "数据处理中",
                "current_step": step,
                "total_steps": total_steps,
                "percentage": round(step / total_steps * 100, 2)
            }
            heartbeat_client.update_status("running", progress)
            
            print(f"执行步骤 {step}/{total_steps}")
            
            # 模拟处理时间
            time.sleep(5)
            
            # 模拟可能的错误
            if step == 3 and config.get('simulate_error'):
                heartbeat_client.update_status("failed", {"error": "模拟错误"})
                heartbeat_client.send_completion(
                    success=False,
                    error_message="模拟任务执行错误"
                )
                return 1
        
        # 任务完成
        heartbeat_client.update_status("completed", {"stage": "任务完成"})
        
        # 发送完成通知
        result_data = {
            "processed_records": 1000,
            "output_files": ["result.json", "summary.txt"],
            "execution_time": "2.5分钟"
        }
        
        heartbeat_client.send_completion(
            success=True,
            result_data=result_data
        )
        
        print("任务执行完成")
        return 0
        
    except KeyboardInterrupt:
        print("收到中断信号，正在停止任务...")
        heartbeat_client.send_completion(
            success=False,
            error_message="任务被用户中断"
        )
        return 1
        
    except Exception as e:
        print(f"任务执行异常: {e}")
        heartbeat_client.send_completion(
            success=False,
            error_message=str(e)
        )
        return 1
        
    finally:
        # 停止心跳
        heartbeat_client.stop()

if __name__ == "__main__":
    exit(main())
```

### 配置文件示例

```json
{
  "task_name": "示例数据采集任务",
  "task_type": "crawler",
  "base_url": "https://example.com",
  "simulate_error": false,
  "processing_config": {
    "batch_size": 100,
    "max_retries": 3,
    "timeout": 30
  }
}
```

## Docker容器配置

### Dockerfile示例

```dockerfile
FROM python:3.9-slim

# 安装依赖
RUN pip install requests

# 复制应用代码
COPY heartbeat_client.py /app/
COPY task_service.py /app/
COPY requirements.txt /app/

# 设置工作目录
WORKDIR /app

# 安装Python依赖
RUN pip install -r requirements.txt

# 设置环境变量
ENV PYTHONPATH=/app
ENV API_BASE_URL=http://data-platform-api:8000

# 运行任务服务
CMD ["python", "task_service.py"]
```

### Docker运行命令

```bash
docker run -d \
  --name task-{execution_id} \
  --rm \
  -v /tmp/task_configs/{execution_id}/config.json:/app/config/config.json:ro \
  -e TASK_EXECUTION_ID={execution_id} \
  -e CONFIG_PATH=/app/config/config.json \
  -e API_BASE_URL=http://your-api-host:8000 \
  your-task-image:latest
```

## 环境变量说明

| 环境变量 | 说明 | 示例值 |
|---------|------|--------|
| `TASK_EXECUTION_ID` | 任务执行ID（UUID格式） | `550e8400-e29b-41d4-a716-446655440000` |
| `CONFIG_PATH` | 配置文件在容器内的路径 | `/app/config/config.json` |
| `API_BASE_URL` | 主控系统API基础URL | `http://data-platform-api:8000` |
| `HOSTNAME` | 容器ID（自动设置） | `task-550e8400-e29b-41d4-a716-446655440000` |

## 网络配置

### 容器网络访问

确保Docker容器能够访问主控系统的API：

1. **同一Docker网络**: 将任务容器加入与API服务相同的Docker网络
2. **端口映射**: 如果API服务有端口映射，使用宿主机IP访问
3. **服务发现**: 使用Docker Compose的服务名进行访问

### 防火墙配置

确保以下端口开放：
- API服务端口（默认8000）
- Redis端口（如果API服务需要访问Redis）

## 故障排除

### 常见问题

1. **心跳发送失败**
   - 检查网络连接
   - 确认API服务地址正确
   - 检查防火墙设置

2. **执行ID格式错误**
   - 确认环境变量设置正确
   - 检查UUID格式（36个字符）

3. **配置文件读取失败**
   - 检查配置文件挂载路径
   - 确认文件权限

### 调试技巧

1. **启用详细日志**
   ```python
   import logging
   logging.basicConfig(level=logging.DEBUG)
   ```

2. **测试网络连接**
   ```bash
   # 在容器内测试API连接
   curl -X POST http://api-host:8000/api/v1/monitoring/heartbeat \
     -H "Content-Type: application/json" \
     -d '{"execution_id":"test","container_id":"test","status":"running"}'
   ```

3. **检查环境变量**
   ```bash
   # 在容器内查看环境变量
   env | grep -E "(TASK_EXECUTION_ID|CONFIG_PATH|API_BASE_URL)"
   ```
